class CardPile
  constructor: ->
    @cards = []

  shuffle: ->
    ###
    Fisher Yates Shuffle algorithm for arrays
    ###
    i = @cards.length
    if i is 0
      return false

    while --i
      j = Math.floor( Math.random() * ( i + 1 ) )
      tempi = @cards[i]
      tempj = @cards[j]
      @cards[i] = tempj
      @cards[j] = tempi

  push: (card) ->
    card.currentPile = @
    @cards.push card

  takeNextCard: () ->
    @cards.shift()

  takeAllCards: () ->
    @cards.splice 0

  getSaveData: ->
    cards = []
    for card in @cards
      cards.push card.getSaveData()
    return {
      cards: cards
    }

  loadData: (data) ->
    @cards.length = 0
    for card in data.cards
      card = new Card(card.value, card.suit)
      @push card

class UnusedCardPile extends CardPile
  constructor: ->
    super()
    @name = "unused"

class UsedCardPile extends CardPile
  constructor: ->
    super()
    @name = "used"

  push: (card) ->
    super(card)
    card.isFlipped = no

class PlayerCardPile extends CardPile
  constructor: (@name, @index)->
    super()
    @isRevealingAll = yes

  push: (card) ->
    super(card)
    if @isRevealingAll or @cards.length is 1
      card.isFlipped = yes

  reveal: ->
    @isRevealingAll = yes
    for card in @cards
      card.isFlipped = yes

  value: ->
    if !@cards.length
      return 0

    if !@isRevealingAll
      return "?"

    handValue = 0
    aceCount = 0

    for card in @cards
      switch card.value
        when "A"
          aceCount++
        when "J","Q","K"
          handValue += 10
        else
          handValue += card.value

    if aceCount?
      for i in [0...aceCount]
        if handValue <= 10
          handValue += 11
        else
          handValue += 1

    return handValue

class PlayerInventoryCardPile extends CardPile